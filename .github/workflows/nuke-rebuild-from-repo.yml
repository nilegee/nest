name: Nuke & Rebuild DB from Repo (manual)

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: "Type: NUKE"
        required: true
        default: ""
      family_name:
        description: "Family display name (minimal seed)"
        required: false
        default: "G Family"
      admin_emails:
        description: "Comma-separated admin emails"
        required: false
        default: "nilezat@gmail.com,abdessamia.mariem@gmail.com"
      member_emails:
        description: "Comma-separated member emails"
        required: false
        default: "yahyageemail@gmail.com,yazidgeemail@gmail.com"

jobs:
  nuke-rebuild:
    runs-on: ubuntu-latest
    env:
      RAW_DATABASE_URL: ${{ secrets.DATABASE_URL }}
      RAW_DATABASE_URL_POOLER: ${{ secrets.DATABASE_URL_POOLER }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Require explicit confirmation
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "NUKE" ]; then
            echo "Refusing to run without confirm=NUKE"; exit 1;
          fi

      - name: Install PostgreSQL client 17
        run: |
          set -euo pipefail
          sudo mkdir -p /usr/share/keyrings
          curl -fsSL https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo gpg --dearmor -o /usr/share/keyrings/postgresql.gpg
          echo "deb [signed-by=/usr/share/keyrings/postgresql.gpg] http://apt.postgresql.org/pub/repos/apt/ $(lsb_release -cs)-pgdg main 17" | sudo tee /etc/apt/sources.list.d/pgdg.list
          sudo apt-get update
          sudo apt-get install -y postgresql-client-17
          /usr/lib/postgresql/17/bin/psql --version
          /usr/lib/postgresql/17/bin/pg_dump --version

      - name: Sanitize DATABASE_URL
        run: |
          set -euo pipefail
          url="${RAW_DATABASE_URL_POOLER:-${RAW_DATABASE_URL:-}}"
          # Prefer DIRECT URL for DDL if present
          [ -n "$RAW_DATABASE_URL" ] && url="$RAW_DATABASE_URL"
          if [ -z "$url" ]; then echo "No DATABASE_URL/POOLER set"; exit 1; fi
          url="${url#"\""}"; url="${url%"\""}"
          url="${url//sslmode=\"require\"/sslmode=require}"
          url="${url//%22require%22/require}"
          if [[ "$url" != *"sslmode="* ]]; then
            sep="&"; [[ "$url" != *"?"* ]] && sep="?"
            url="${url}${sep}sslmode=require"
          fi
          echo "SANITIZED_URL=$url" >> $GITHUB_ENV

      - name: Preflight versions
        env:
          DB: ${{ env.SANITIZED_URL }}
        run: |
          set -euo pipefail
          echo "Server version:"
          /usr/lib/postgresql/17/bin/psql "$DB" -Atc "select version();"

      - name: Backup (custom format)
        env:
          DB: ${{ env.SANITIZED_URL }}
        run: |
          set -euo pipefail
          TS=$(date +%Y%m%d%H%M%S)
          OUT="backup_${TS}.dump"
          /usr/lib/postgresql/17/bin/pg_dump --format=custom --no-owner --no-privileges --file "$OUT" "$DB"
          echo "OUT=$OUT" >> $GITHUB_ENV

      - name: Upload backup artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.OUT }}
          path: ${{ env.OUT }}
          retention-days: 30
          if-no-files-found: error

      - name: Nuke public schema (keep system schemas)
        env:
          DB: ${{ env.SANITIZED_URL }}
        run: |
          set -euo pipefail
          /usr/lib/postgresql/17/bin/psql "$DB" -v ON_ERROR_STOP=1 <<'SQL'
          REVOKE CREATE ON SCHEMA public FROM PUBLIC;
          DROP SCHEMA IF EXISTS public CASCADE;
          CREATE SCHEMA public AUTHORIZATION postgres;
          GRANT USAGE ON SCHEMA public TO postgres, anon, authenticated, service_role;
          GRANT CREATE ON SCHEMA public TO postgres, service_role;
          ALTER SCHEMA public OWNER TO postgres;
          SQL
          echo "Public schema reset."

      - name: Apply repo migrations (if any)
        env:
          DB: ${{ env.SANITIZED_URL }}
        run: |
          set -euo pipefail
          if ls -1 supabase/migrations/*.sql >/dev/null 2>&1; then
            for f in $(ls -1 supabase/migrations/*.sql | sort); do
              echo "Applying $f"
              /usr/lib/postgresql/17/bin/psql "$DB" -v ON_ERROR_STOP=1 -f "$f"
            done
          else
            echo "No migration files found under supabase/migrations"
          fi
          echo "Migrations applied."

      - name: Seed minimal data (Family + Email Whitelist)
        env:
          DB: ${{ env.SANITIZED_URL }}
          FAMILY_NAME: ${{ github.event.inputs.family_name }}
          ADMIN_EMAILS: ${{ github.event.inputs.admin_emails }}
          MEMBER_EMAILS: ${{ github.event.inputs.member_emails }}
        run: |
          set -euo pipefail
          # If a dedicated seed exists, run that instead.
          if [ -f supabase/seed.sql ]; then
            echo "Running supabase/seed.sql"
            /usr/lib/postgresql/17/bin/psql "$DB" -v ON_ERROR_STOP=1 -f supabase/seed.sql
            exit 0
          fi

          echo "Running minimal seed (family + whitelist)"
          /usr/lib/postgresql/17/bin/psql "$DB" -v ON_ERROR_STOP=1 <<'SQL'
          -- Minimal, profile-safe seed.
          -- Does NOT touch auth.users or profiles (created on first login).

          -- Ensure families table exists (if migrations didn't already create it)
          DO $$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables
                           WHERE table_schema='public' AND table_name='families') THEN
              CREATE TABLE public.families (
                id uuid primary key default gen_random_uuid(),
                name text unique not null
              );
            END IF;
          END $$;

          -- Use a simple text role with a CHECK to avoid enum mismatch during early testing
          DO $$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM information_schema.tables
                           WHERE table_schema='public' AND table_name='email_whitelist') THEN
              CREATE TABLE public.email_whitelist (
                email citext primary key,
                role  text not null check (role in ('admin','member'))
              );
            END IF;
          END $$;

          -- Upsert Family
          INSERT INTO public.families(name) VALUES (:FAMILY_NAME)
          ON CONFLICT (name) DO NOTHING;

          -- Upsert whitelisted emails
          WITH
          admins AS (
            SELECT trim(value) AS email
            FROM regexp_split_to_table(:ADMIN_EMAILS, ',') AS value
            WHERE trim(value) <> ''
          ),
          members AS (
            SELECT trim(value) AS email
            FROM regexp_split_to_table(:MEMBER_EMAILS, ',') AS value
            WHERE trim(value) <> ''
          )
          INSERT INTO public.email_whitelist(email, role)
          SELECT email, 'admin' FROM admins
          UNION ALL
          SELECT email, 'member' FROM members
          ON CONFLICT (email) DO UPDATE SET role = EXCLUDED.role;

          -- Optional helper view for quick checks (safe if it already exists)
          DO $$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_views WHERE schemaname='public' AND viewname='whitelisted_admins') THEN
              EXECUTE $$CREATE VIEW public.whitelisted_admins AS
                       SELECT email FROM public.email_whitelist WHERE role='admin'$$;
            END IF;
          END $$;
          SQL

      - name: Post-run summary
        env:
          DB: ${{ env.SANITIZED_URL }}
        run: |
          set -euo pipefail
          echo "Schema objects now present:"
          /usr/lib/postgresql/17/bin/psql "$DB" -Atc "select 'tables='||count(*) from pg_tables where schemaname='public';"
          /usr/lib/postgresql/17/bin/psql "$DB" -Atc "select 'whitelist_emails='||(select count(*) from public.email_whitelist);"
          /usr/lib/postgresql/17/bin/psql "$DB" -Atc "select 'family='||(select name from public.families limit 1);"
          echo "Done."